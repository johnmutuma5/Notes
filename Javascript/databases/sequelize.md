# SEQUELIZE TUTORIAL
These notes have been taken from the following tutorial on youtube.

[![](https://img.youtube.com/vi/6NKNfXtKk0c/maxresdefault.jpg)](https://www.youtube.com/watch?v=6NKNfXtKk0c&list=PL5ze0DjYv5DYBDfl0vF_VRxEu8JdTIHlR&index=2 "Sequelize tutorials")

## Table of Contents
- [Getting Started](#getting-started)
    - [Loading sequelize](#loading-sequelize)
    - [Creating a connection](#creating-a-connection)
    - [Creating a table](#creating-a-table)
    - [Creating a record](#creating-a-record)
- [Defining Models](#defining-models)
    - [Passing options to sync](#passing-options-to-sync)
    - [Custom `Primary Key`](#custom-primary-Key)
- [Validation Rules](#validation-rules)
- [Hooks](#hooks)
- [CRUD with sequelize](#crud-with-sequelize)
    - [Creating ](#creating)


## Getting started
The first thing we need to do is to install the sequelize module in the project as a production dependency `npm install --save sequelize`.
From the [documentation](http://docs.sequelizejs.com/manual/installation/getting-started.html#installation), select one of the database adapters according to the database you're using. e.g. `npm install --save pg pg-hstore` for PostgreSQL.

### Loading sequelize
To load sequelize, we simply `require` it:

```js
// app.js
const Sequelize = require('sequelize');
```

Note the capitalization of `Sequelize` above, because the on `requiring`, we get a contructor function that should be invoked with the `new` keyword.

### Creating a connection
There are two ways through which we can connect to the database after installing the modules above.

First, we can use a bare string representing the database URI:
```js
// app.js
const Sequelize = require('sequelize');
const connection = new Sequelize('postgres://user:pass@example.com:5432/dbname', {});
```

The second argument in the constructor above is an object of options. You can see the [API Reference](http://docs.sequelizejs.com/class/lib/sequelize.js~Sequelize.html) for a whole range of options available.

The alternative way of creating a connection to the database is by using the following criteria;

```js
// app.js
const Sequelize = require('sequelize');
const connection = new Sequelize('database_name', 'user', 'password', {
    dialect: 'postgres'
});
```

### Creating a table
After the connection has successfully been created, we can now perform database transactions like creating a table as follows;

```js
// app.js
const Sequelize = require('sequelize');
const connection = new Sequelize('database_name', 'user', 'password', {
    dialect: 'postgres'
});

// create a table users
const User = connection.define('users', {
    name: Sequelize.STRING,
    home_area: Sequelize.STRING
});

connection.sync();
```
The script above will create a table `users` in the database with the specified fields. In addition, we get some extra fields including `id` which is a database autogenerated sequence of record `id`s, `createdAt` and `updatedAt` are also autogenerated database `TIMESTAMP`s. With regards to the autogenerated fields, we can have control which we'll see later in these notes.

### Creating a record
`connection.sync()` is asynchronous and returns `Promise` object after it has synced with the database. After the `promise` has resolved, we can go ahead and create a record as follows;

```js
// app.js
// ...

connection.sync()
    .then(function() {
        User.create({
            name: 'Laz',
            home_area: 'Kiambu Rd'
        });
    });

```

### Finding records
We can use `.findById` to find records by `id` and access the data from the found object using `dataValues` as follows;

```js
// app.js
// ...

connection.sync()
    .then(function() {
        User.findById(1)
            .then(function(user) {
                console.log(user.dataValues);
            });
    });
```

To retrieve all records, we can use `findAll` as;


```js
// app.js
// ...

connection.sync()
    .then(function() {
        User.findAll()
            .then(function(users) {
                console.log(users.dataValues);
            });
    });
```

`.findAll` can be quite taxing to the application especially if there are several records in the database so it is advisable to use pagination with this method.

## Defining Models
The model we defined in the previous section was the bare minimum basic. In real applications, we may desire more control with our models including custom `primary keys`, `constraints`, `default values` etc. This section will delve into a bit of that for a good start.

When defining the model fields, we can use a more extensible and explicit syntax to fine-tune our models;

```js
// app.js
// ...

// create a table users
const User = connection.define('users', {
    name: {type: Sequelize.STRING},
    home_area: {type: Sequelize.STRING},
    post: {
        type: Sequelize.TEXT,
        defaultValue: 'God is with us...    '
    },
    email: {
        type: Sequelize.STRING,
        unique: true,
        allowNull: false
    }
});

connection.sync();

```
In the script above, we make use of `defaultValue` as well as `unique` and `allowNull` constraints.

So far, the `define` method has taken two arguments, the table name and an object containing the fields of the table and their properties. However, there is a third argument that we can provide to pass some options. For instance, we may want to disable the autogenerated `TIMESTAMP` fields and we can achieve that as follows;


```js
// app.js
// ...

// create a table users
const User = connection.define('users', {
        name: {type: Sequelize.STRING},
        home_area: {type: Sequelize.STRING},
    }, {
        timestamp: false
    }
);

connection.sync();

```

There is a variety of other options you can pass e.g. `freezeTableName` to prevent `sequelize` from auto-pluralizing the table names. We can also declare [hooks](#hooks) here.

### Passing options to sync
The `sync` method can also take an object of options. For instance, when creating tables, `sync` only creates tables if they do not exist. We can override this by passing an option to `sync` as follows;

```js
// app.js
// ...
connection.sync({force: true});
```

***NB: This is going to drop the tables that already exist and it is not good for production databases.***

We can also disable console-logging of `SQL` statements with the `logging` option;

```js
// app.js
// ...
connection.sync({logging: false});
```

### Custom `Primary Key`
In the `define` method, while specifying the fields' attributes, we can specify a primary key and this will prevent `sequelize` from autogenerating one;

```js
// app.js
// ...

// create a table users
const User = connection.define('users', {
        email: {
            type: Sequelize.STRING,
            primaryKey: true
        },
        name: {type: Sequelize.STRING},
        home_area: {type: Sequelize.STRING},
    }
);

connection.sync();
```

## Validation Rules
Besides validations like `allowNull` and `unique`, `sequelize` also avails other validation options which you can find in the [documentation](http://docs.sequelizejs.com/manual/tutorial/models-definition.html#validations "sequelize validations").

The database throws errors when these validations are not satisfied. These errors should be caught from the `promise`.

```js
// app.js
// ...

// create a table users
const User = connection.define('users', {
    name: {type: Sequelize.STRING},
    home_area: {type: Sequelize.STRING},
    email: {
        type: Sequelize.STRING,
        unique: true,
        allowNull: false,
        validation: {
            contains: 'andela',
            is: /^[a-z]+$/i // put a valid regex here for emails
        }
    }
});

connection.sync();
```

Besides providing values for validation, we can also use an object to specify more options e.g. a custom message.

```js
// app.js
// ...

    email: {
        type: Sequelize.STRING,
        unique: true,
        allowNull: false,
        validation: {
            contains: {
                args: 'andela',
                msg: 'The email must include "andela"'
            }
        }
    }
// ...

connection.sync();
```

We are also able to define custom validation rules with a function;

```js
// app.js
// ...

    email: {
        type: Sequelize.STRING,
        unique: true,
        allowNull: false,
        validation: {
            includesAndela: function(email) {
                if(!email.includes('andela'))
                    throw new Error('The email must include "andela"')
            }
        }
    }
// ...

connection.sync();
```


## Hooks
These are important lifecycle hooks that are specified for the table in the `define` method's third argument, which is an object. There are a number of hooks to our disposal as can be seen from the [documentation](http://docs.sequelizejs.com/manual/tutorial/hooks.html) Some of these include:

- `beforeValidate`
- `beforeCreate`

and some more.

```js
// app.js
// ...

// create a table users
const User = connection.define('users', {
        name: {type: Sequelize.STRING},
        home_area: {type: Sequelize.STRING},
    }, {
        timestamp: false,
        hooks: {
            beforeCreate: function() {
                console.log('before create');
            }
        }
    }
);

connection.sync();
```

An alternative way of setting up `hooks` is on the model as follows;

```js
// app.js
// ...

// create a table users
const User = connection.define('users', {
        name: {type: Sequelize.STRING},
        home_area: {type: Sequelize.STRING},
    }, {
        timestamp: false
    }
);

// method 2
User.hooks('beforeValidate', function(user, options){
    console.log(`validating ${user.username}`);
});

// method 3

User.beforeCreate("<HookName::optional", function(user, options) {
    console.log(`creating ${user.username}`);
});

connection.sync();
```

A very good instance of lifecycle hooks use case is in password hashing. i.e. `afterValidate`.

## CRUD with sequelize
### Creating
